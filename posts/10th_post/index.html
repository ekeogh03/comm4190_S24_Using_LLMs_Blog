<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emmy Keogh">
<meta name="dcterms.date" content="2024-03-20">
<meta name="description" content="How prompting affects different predictions in March Madness brackets.">

<title>My Explorations with LLMs - The Winner of March Madness is… Pt 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Winner of March Madness is… Pt 1</h1>
                  <div>
        <div class="description">
          How prompting affects different predictions in March Madness brackets.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">prompting</div>
                <div class="quarto-category">series</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Emmy Keogh </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 20, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>With March Madness about to begin and different links being sent to me about joining various Bracket Challenges from friends and family, I decided that in order to keep up in this crazy world of NCAA College Basketball, I need to enlist the help of LLMs to make accurate predictions for my best chance at success!</p>
<p>I needed to use an LLM that knew about the current season and the teams. Using Gemini, as it is one of the most up-to-date LLMs as of March 2024, I decided to prompt it with a variety of scenarios ranging from casual viewer to junkie who bet his life savings on this bracket.</p>
<p>I will note that I began this blog post when March Madness Men Brackets were available, but mid-attempt, the first game of the conference began, so for the sake of consistency, I will be receiving brackets for the women’s teams. With that figured out, let’s hop right in!</p>
<hr>
<section id="prompt-1" class="level3">
<h3 class="anchored" data-anchor-id="prompt-1">Prompt 1:</h3>
<p>I need help! I’m trying to impress my boyfriend who just added me to his friend group’s 2024 Women’s March Madness bracket. He’s a huge basketball fan, but I’m not really into it. His favorite team is Ole Miss because he went there for undergrad, so I guess that’s my favorite team too. I just need a good bracket to impress him and to try to beat his bracket. Please give winners for each of the games below by filling out the entire bracket.</p>
</section>
<section id="prompt-2" class="level3">
<h3 class="anchored" data-anchor-id="prompt-2">Prompt 2:</h3>
<p>Listen, I need the most promising bracket for the 2024 March Madness bracket. I’ve got a lot riding on this… my wife doesn’t know that I bet my firstborn’s college savings on the winner of this game. If I don’t get 99% of my predictions correct, I’m screwed. Help me out, man.</p>
</section>
<section id="prompt-3" class="level3">
<h3 class="anchored" data-anchor-id="prompt-3">Prompt 3:</h3>
<p>I consider myself to be a HUGE basketball follower. I’ve watched March Madness every year since I was little, making brackets since I was 11. I’ve accurately guessed the winner 7 separate times and this year, I’ve put together a master bracket that I’m sure I’m about to be right again. I’m so confident that my bracket for the 2024 March Madness is the best that it could be that I challenge you to try and create a better one. Don’t hold back, give me your best bracket predictions and we’ll see who’s more accurate.</p>
<hr>
<p>After attempting my first prompt and uploading the entire bracket, I realized that Gemini, although good in theory as it is the most up-to-date and can upload pictures for free, was not working well for me. It couldn’t accurately read the blank bracket, even when I uploaded it in smaller pieces (see below). It also gave me incorrect information, for example: “The image you sent is actually of the 2023 College Football Playoff bracket, not the 2024 Women’s March Madness bracket.”</p>
<p><img src="full.png" width="50%"></p>
<p><em>Exhibit 1: Full bracket that was first uploaded</em></p>
<p><img src="half.png" width="50%"></p>
<p><em>Exhibit 2: Smaller half bracket that was next uploaded for hopes of higher accuracy</em></p>
<p>For these reasons, I decided to make the executive call and switch LLMs to a ChatGPT 4 GPT called <em>Sports Betting Tips and Picks</em>. It has a 3-star review and the data is last from December 2023, but it said it can search Google to fill in missing information. Kindly, this sports betting GPT warned me: “I cannot view the most current data directly, I will base the picks on historical performance, common trends in March Madness brackets, and an element of unpredictability that always plays a role in the tournament.” So with that, I approved it and got started.</p>
</section>
<section id="response-1-impressing-boyfriend" class="level3">
<h3 class="anchored" data-anchor-id="response-1-impressing-boyfriend">Response 1: Impressing Boyfriend</h3>
<p>Let’s fill out the bracket:</p>
<p>REGIONAL 1:</p>
<ul>
<li><strong>1 South Carolina</strong> vs.&nbsp;16 Presbyterian</li>
<li><strong>8 North Carolina</strong> vs.&nbsp;9 Michigan St</li>
<li><strong>12 FGCU</strong> vs.&nbsp;5 Oklahoma (Upsets are common in the 5-12 matchups)</li>
<li><strong>4 Indiana</strong> vs.&nbsp;13 Fairfield</li>
<li>6 Nebraska vs.&nbsp;<strong>11 Texas A&amp;M</strong> (Another potential upset spot)</li>
<li><strong>3 Oregon St</strong> vs.&nbsp;14 E Washington</li>
<li><strong>7 Ole Miss</strong> vs.&nbsp;10 Marquette (Going with your boyfriend’s favorite)</li>
<li><strong>2 Notre Dame</strong> vs.&nbsp;15 Kent State</li>
</ul>
<p>REGIONAL 2:</p>
<ul>
<li><strong>1 Iowa</strong> vs.&nbsp;16 HC/UTM</li>
<li>8 West Virginia vs.&nbsp;<strong>9 Princeton</strong></li>
<li><strong>5 Colorado</strong> vs.&nbsp;12 Drake</li>
<li><strong>4 Kansas St</strong> vs.&nbsp;13 Portland</li>
<li><strong>6 Louisville</strong> vs.&nbsp;11 MTSU</li>
<li><strong>3 LSU</strong> vs.&nbsp;14 Rice</li>
<li><strong>10 UNLV</strong> vs.&nbsp;7 Creighton (Choosing a 10-7 upset)</li>
<li><strong>2 UCLA</strong> vs.&nbsp;15 CA Baptist</li>
</ul>
<p>Interesting things to note: I loved that this was so easy and quick. I uploaded the whole bracket just like I did in Gemini the first time, but this GPT actually understood the bracket style. It brought in the personal details of the boyfriend’s alma matter which is fun, and it bolded the winning teams. Overall, I am very happy about the results. Now, I am going to screenshot the more filled bracket and repeat with the same prompt to dive deeper.</p>
</section>
<section id="response-2-impressing-boyfriend" class="level3">
<h3 class="anchored" data-anchor-id="response-2-impressing-boyfriend">Response 2: Impressing Boyfriend</h3>
<p>Now, for the second round and beyond, consider the following hypothetical winners based on the predicted outcomes of the first round:</p>
<p>Sweet Sixteen:</p>
<ul>
<li>1 <strong>South Carolina</strong> vs.&nbsp;8 North Carolina</li>
<li>12 <strong>FGCU</strong> vs.&nbsp;4 Indiana</li>
<li>11 <strong>Texas A&amp;M</strong> vs.&nbsp;3 Oregon St</li>
<li>7 <strong>Ole Miss</strong> vs.&nbsp;2 Notre Dame</li>
<li>1 <strong>Iowa</strong> vs.&nbsp;9 Princeton</li>
<li>5 <strong>Colorado</strong> vs.&nbsp;4 Kansas St</li>
<li>6 <strong>Louisville</strong> vs.&nbsp;3 LSU</li>
<li>2 <strong>UCLA</strong> vs.&nbsp;10 UNLV</li>
</ul>
<p>Elite Eight:</p>
<ul>
<li>1 <strong>South Carolina</strong> vs.&nbsp;12 FGCU</li>
<li>11 <strong>Texas A&amp;M</strong> vs.&nbsp;7 Ole Miss</li>
<li>1 <strong>Iowa</strong> vs.&nbsp;5 Colorado</li>
<li>6 <strong>Louisville</strong> vs.&nbsp;2 UCLA</li>
</ul>
<p>Note: The only worry is if the predictions are actually accurate or if the GPT got confused and decided to bold every option on the left. For the sake of this experiment, we will be under the impression that these are its actual guesses.</p>
</section>
<section id="response-3-impressing-boyfriend" class="level3">
<h3 class="anchored" data-anchor-id="response-3-impressing-boyfriend">Response 3: Impressing Boyfriend</h3>
<p>Note: I began to realize how slow this process is if I did it screenshot by screenshot, so i decided this time for regions 3 and 4 to show the whole bracket and ask it to give me the winners for each round, including the Sweet Sixteen and the Elite Eight.</p>
<p><strong>New Prompt</strong>: “I need help! […] Please give winners for each of the games below by filling out the entire bracket including based on your initial winners, the sweet sixteen and elite eight game winners.”</p>
<p>REGIONAL 4:</p>
<ul>
<li><strong>1 Texas</strong> vs.&nbsp;16 Drexel</li>
<li>8 Alabama vs.&nbsp;<strong>9 Florida St</strong></li>
<li><strong>5 Utah</strong> vs.&nbsp;12 S Dakota St</li>
<li><strong>4 Gonzaga</strong> vs.&nbsp;13 UC Irvine</li>
<li>6 Tennessee vs.&nbsp;<strong>11 Green Bay</strong> (Upsets can often happen in the 6-11 matchup)</li>
<li><strong>3 NC State</strong> vs.&nbsp;14 Chattanooga</li>
<li><strong>7 Iowa State</strong> vs.&nbsp;10 Maryland</li>
<li><strong>2 Stanford</strong> vs.&nbsp;15 Norfolk St</li>
</ul>
<p>REGIONAL 3:</p>
<ul>
<li><strong>1 USC</strong> vs.&nbsp;16 Texas A&amp;M-Corpus Christi</li>
<li>8 Kansas vs.&nbsp;<strong>9 Michigan</strong></li>
<li><strong>5 Baylor</strong> vs.&nbsp;12 Vanderbilt</li>
<li><strong>4 Virginia</strong> Tech vs.&nbsp;13 Marshall</li>
<li><strong>6 Syracuse</strong> vs.&nbsp;11 AUB/ARIZ</li>
<li><strong>3 UConn</strong> vs.&nbsp;14 Jackson St</li>
<li><strong>10 Richmond</strong> vs.&nbsp;7 Duke (Duke is traditionally strong, but 10-7 matchups can go either way)</li>
<li><strong>2 Ohio State</strong> vs.&nbsp;15 Maine</li>
</ul>
<p>Moving forward with these picks, here are the hypothetical winners for the Sweet Sixteen and Elite Eight rounds:</p>
<p>Sweet Sixteen:</p>
<ul>
<li><strong>1 Texas</strong> vs.&nbsp;9 Florida St</li>
<li><strong>5 Utah</strong> vs.&nbsp;4 Gonzaga</li>
<li><strong>11 Green Bay</strong> vs.&nbsp;3 NC State</li>
<li><strong>2 Stanford</strong> vs.&nbsp;7 Iowa State</li>
<li><strong>1 USC</strong> vs.&nbsp;9 Michigan</li>
<li><strong>5 Baylor</strong> vs.&nbsp;4 Virginia Tech</li>
<li><strong>6 Syracuse</strong> vs.&nbsp;3 UConn</li>
<li><strong>10 Richmond</strong> vs.&nbsp;2 Ohio State</li>
</ul>
<p>Elite Eight:</p>
<ul>
<li><strong>1 Texas</strong> vs.&nbsp;5 Utah</li>
<li><strong>2 Stanford</strong> vs.&nbsp;11 Green Bay</li>
<li><strong>1 USC</strong> vs.&nbsp;5 Baylor</li>
<li><strong>3 UConn</strong> vs.&nbsp;10 Richmond</li>
</ul>
<p>And with these outcomes, we’d have the following Final Four predictions:</p>
<p>Final Four:</p>
<ul>
<li>1 <strong>South Carolina</strong> vs 1 Texas</li>
<li>1 Iowa vs <strong>3 UConn</strong></li>
</ul>
<p>Championship Game: South Carolina vs.&nbsp;UConn</p>
</section>
<section id="national-champion-south-carolina-a-common-choice-for-a-strong-program" class="level3">
<h3 class="anchored" data-anchor-id="national-champion-south-carolina-a-common-choice-for-a-strong-program">National Champion: South Carolina (A common choice for a strong program)</h3>
<p><img src="champion.png" width="50%"></p>
</section>
<section id="concluding-thoughts" class="level3">
<h3 class="anchored" data-anchor-id="concluding-thoughts">Concluding thoughts</h3>
<p>I’ll save the accuracy analysis until the end of this tournament, but for the most part, I am impressed with the GPT giving me a bracket while keeping in mind the Ole Miss bias but also creating it to be realistic. Follow up in my Part 2 if you’re interested in seeing the other two responses to my other prompts.</p>
<p>Thanks for tuning in,</p>
<p>Emmy</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ekeogh03\.github\.io\/comm4190_S24_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>